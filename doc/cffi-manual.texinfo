\input texinfo   @c -*- Mode: Texinfo; Mode: auto-fill -*-
@c %**start of header
@setfilename cffi.info
@settitle CFFI User Manual
@exampleindent 2

@c @documentencoding utf-8
@c %**end of header


@c ============================= Macros =============================
@c The following macros are used throughout this manual.

@macro Function {args}
@defun \args\
@end defun
@end macro

@macro Macro {args}
@defmac \args\
@end defmac
@end macro

@macro Accessor {args}
@deffn {Accessor} \args\
@end deffn
@end macro

@macro ForeignType {args}
@deftp {Foreign Type} \args\
@end deftp
@end macro

@c ============================= Macros =============================


@c Show types in the same index as the functions.
@synindex tp fn

@copying
Copyright @copyright{} 2005, James Bielman  <jamesjb at jamesjb.com> @*
Copyright @copyright{} 2005, Luis Oliveira  <loliveira at common-lisp.net>
@c I wanted to spell my name correctly, with an acute accent over the
@c 'i' in Luis but PDF output won't display correctly if I do so.

@quotation
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the ``Software''), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
@end quotation
@end copying

@titlepage
@title CFFI User Manual
@c @subtitle Version X.X
@c @author James Bielman

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top cffi
@insertcopying
@end ifnottex

@menu
* Introduction::                
* Implementation Support and Known Issues::  
* Foreign Types::               
* Pointers::                    
* Strings::                     
* Variables::                   
* Functions::                   
* Libraries::                   
* Callbacks::                   
* Limitations::                 
* Symbol Index::                

@detailmenu
 --- Dictionary ---

Foreign Types

* defcstruct::                  Defines a C structure type.
* defcunion::                   Defines a C union type.
* defctype::                    Defines a foreign typedef.
* defcenum::                    Defines a C enumeration.
* define-type-translator::      Defines a type translation.
@c * define-type-spec-parser::     <should be exported?>
* define-foreign-type::         Defines a foreign type specifier.
* explain-foreign-slot-value::  <unimplemented>
* foreign-enum-keyword::        Finds a keyword in an enum type.
* foreign-enum-value::          Finds a value in an enum type.
* foreign-slot-names::          Returns a list of slot names in a foreign struct.
* foreign-slot-offset::         Returns the offset of a slot in a foreign struct.
* foreign-slot-pointer::        Returns a pointer to a slot in a foreign struct.
* foreign-slot-value::          Returns the value of a slot in a foreign struct.
* foreign-type-alignment::      Returns the alignment of a foreign type.
* foreign-type-size::           Returns the size of a foreign type.
* with-foreign-object::         Allocates a foreign object with dynamic extent.
* with-foreign-slots::          Access the slots of a foreign structure.

Pointers

* foreign-free::                Deallocates memory.
* foreign-alloc::               Allocates memory.
* foreign-symbol-pointer::      Returns a pointer to a foreign symbol.
* inc-pointer::                 Increments the address held by a pointer.
* make-pointer::                Returns a pointer to a given address.
* mem-aref::                    Accesses the value of an index in an array.
* mem-ref::                     Dereferences a pointer.
* null-pointer::                Returns a NULL pointer.
* null-pointer-p::              Tests a pointer for NULL value.
* pointerp::                    Tests whether an object is a pointer or not.
* pointer-address::             Returns the address pointed to by a pointer.
* pointer-eq::                  Tests if two pointers point to the same address.
* with-foreign-pointer::        Allocates memory with dynamic extent.

Strings

* foreign-string-alloc::        Converts a Lisp string to a foreign string.
* foreign-string-free::         Deallocates memory used by a foreign string.
* foreign-string-to-lisp::      Converts a foreign string to a Lisp string.
* lisp-string-to-foreign::      Copies a Lisp string into a foreign string.
* with-foreign-string::         Allocates a foreign string with dynamic extent.
* with-foreign-pointer-as-string::  Similar to CL's with-output-to-string.

Variables

* defcvar::                     Defines a C global variable.
* get-var-pointer::             Returns a pointer to a defined global variable.

Functions

* defcfun::                     Defines a foreign function.
* foreign-funcall::             Performs a call to a foreign function.

Libraries

* load-foreign-library::        Loads a foreign library.

Callbacks

* callback::                    Returns a pointer to a defined callback.
* defcallback::                 Defines a Lisp callback.
* get-callback::                Returns a pointer to a defined callback.

@end detailmenu
@end menu




@c ===================================================================
@c CHAPTER: Introduction

@node Introduction
@chapter Introduction

@strong{Please note that, at the moment, this manual reflects what's
available in the cffi-luis branch, not the main cffi branch. Also,
it is a work in progress. --luis}

@section Motivation

@section Design Philosophy

@itemize
@item
Pointers do not carry around type information. Instead, type
information is supplied when pointers are dereferenced.
@item
A type safe pointer interface can be developed on top of an
untyped one.  It is difficult to do the opposite.
@item
Functions are better than macros.  When a macro could be used
for performance, use a compiler-macro instead.
@end itemize




@c ===================================================================
@c CHAPTER: Implementation Support and Known Issues

@node Implementation Support and Known Issues
@chapter Implementation Support and Known Issues

@strong{Please note that, at the moment, this manual reflects what's
available in the cffi-luis branch, not the main cffi branch. --luis}

CFFI supports various free and commercial Lisp implementations:
Allegro CL, Corman CL, CLISP, CMUCL, ECL, Lispworks, OpenMCL and
SBCL.

There are also plans to support Digitool MCL, GCL and Scieneer CL.


@section Allegro CL

@strong{Tested platforms:} linux/x86, linux/ppc, win32/x86, darwin/ppc.

Both the 6.2 and 7.0 versions are supported. The 8.0 beta is also
known to work. Earlier versions are untested and unsupported.

@subheading Known issues
@itemize
@item
@emph{(all platforms)} CFFI won't work correctly using
modern mode.

@item
@emph{(all platforms)} Does not support (unsigned) long long.

@item
@emph{(v6.2, darwin/ppc)} Due to a bug in Allegro, 4 callback tests
fail: @code{CALLBACKS.CHAR, CALLBACKS.UNSIGNED-CHAR, CALLBACKS.SHORT,
CALLBACKS.UNSIGNED-SHORT}. This is fixed in version 7.0.

@item
@emph{(v8.0b, linux/ppc)} Fails FUNCALL.VARARGS.DOUBLE.
@end itemize


@section Corman CL

@strong{Tested platforms:} win32/x86.

Versions prior to 2.51 are untested and unsupported. Also, you will
need to avoid Corman's buggy @code{COMPILE-FILE} and fasl
loader. Please follow @uref{http://www.weitz.de/corman-asdf/, these
instructions} by Edi Weitz to setup ASDF for Corman CL in a way that
works around these issues.

@subheading Known issues
@itemize
@item
@emph{(win32/x86)} No @code{FOREIGN-FUNCALL}.

@item
@emph{(win32/x86)} 7 tests fail.

@item
@emph{(win32/x86)} Does not support (unsigned) long long.
@end itemize


@section CLISP

@strong{Tested platforms:} linux/x86, linux/ppc, win32/x86, darwin/ppc.

Version is 2.34 or newer is required on win32/x86. For other platforms
version 2.35 or newer is required.

@subheading Known issues
@itemize
@item
@emph{(all platforms)} Does not support (unsigned) long long.

@item
@emph{(linux/ppc)} Fails @code{FUNCALL.VARARGS.DOUBLE}.
@end itemize


@section CMUCL

@strong{Tested platforms:} linux/x86, darwin/ppc.

Versions prior to 19B are untested. For darwin/ppc, the 2005-12 (19C)
snapshot or later is recommended.

@c @subheading Known issues

@section ECL

@strong{Tested platforms:} @emph{needs testing...}

As of November 2005, the CVS version of ECL is required. It is
reported to pass all tests.

@subheading Known issues
@itemize
@item
@emph{(all platforms)} Does not support (unsigned) long long.
@end itemize


@section Lispworks

@strong{Tested platforms:} linux/x86, win32/x86, darwin/ppc.

Versions prior to 4.4 are untested.

@subheading Known issues
@itemize
@item
@emph{(all platforms)} No @code{FOREIGN-FUNCALL}.

@item
@emph{(all platforms)} Does not support (unsigned) long long.
@end itemize


@section OpenMCL

@strong{Tested platforms:} darwin/ppc, linux/ppc.

OpenMCL 1.0 or newer is recommended.

@subheading Known issues
@itemize
@item
@emph{(darwin/ppc and linux/ppc)} Fails the tests
@code{CALLBACKS.LONG-LONG} and @code{FOREIGN-GLOBALS.SET.LONG-LONG}.

@item
@emph{(ppc64)} There seem to be some bugs that affect CFFI.
@end itemize


@section SBCL

@strong{Tested platforms:} linux/x86, linux/ppc, darwin/ppc.

Version 0.9.6 or newer is recommended.

@subheading Known issues
@itemize
@item
@emph{(non linux/86)} Callbacks are linux/x86 only.

@item
@emph{(linux/ppc)} Fails 3 tests: @code{FUNCALL.LONG-LONG,
DEFCFUN.LONG-LONG} and @code{FUNCALL.VARARGS.DOUBLE}.
@end itemize




@c
@c TODO: add some sort of tutorial/quickstart chapter here. Mainly
@c describe what can be done (and what needs to be done in general to
@c access a foreign library), and what CFFI offers to that
@c purpose. The the various following chapters should begin with
@c similar tutorials specific to each topic, besides the reference
@c documentation.
@c
@c Not to forget, a section on obtaining and installing CFFI.
@c

@c ===================================================================
@c CHAPTER: Foreign Types

@node Foreign Types
@chapter Foreign Types

Foreign types describe how data is translated back and forth between C
and Lisp. CFFI provides various built-in types and allows the user to
define new types.

@menu
* Built-In Types::              
* Defining Typedefs::           
* Foreign Type Translators::    
* Foreign Structure Types::     
* Operations on Types::         
* Allocating Foreign Objects::  

Dictionary

* defcstruct::                  
* defcunion::                   
* defctype::                    
* defcenum::                    
* define-type-translator::      
@c * define-type-spec-parser::     
* define-foreign-type::         
* explain-foreign-slot-value::        
* foreign-enum-keyword::        
* foreign-enum-value::          
* foreign-slot-names::          
* foreign-slot-offset::         
* foreign-slot-pointer::        
* foreign-slot-value::          
* foreign-type-alignment::      
* foreign-type-size::           
* with-foreign-object::         
* with-foreign-slots::          
@end menu

@c @menu
@c Dictionary
@c 
@c * defctype::
@c * define-foreign-type::
@c * define-type-translator::
@c @end menu

@node Built-In Types
@section Built-In Types

@ForeignType{:char}
@ForeignType{:unsigned-char}
@ForeignType{:short}
@ForeignType{:unsigned-short}
@ForeignType{:int}
@ForeignType{:unsigned-int}
@ForeignType{:long}
@ForeignType{:unsigned-long}
@ForeignType{:long-long}
@ForeignType{:unsigned-long-long}

These types correspond to the native C integer types according to the
ABI of the system the Lisp implementation is compiled against.

@code{:long-long} and @code{:unsigned-long-long} are not supported on
all implementations. When not supported, the @code{:cffi/no-long-long}
feature is pushed into @code{*features*}.

@ForeignType{:int8}
@ForeignType{:uint8}
@ForeignType{:int16}
@ForeignType{:uint16}
@ForeignType{:int32}
@ForeignType{:uint32}
@ForeignType{:int64}
@ForeignType{:uint64}

Foreign integer types of specific sizes, corresponding to the C types
defined in @code{stdint.h}.

@emph{Note: these are not implemented yet. --luis}

@ForeignType{:size}
@ForeignType{:ssize}
@ForeignType{:ptrdiff}
@ForeignType{:time}

Foreign integer types corresponding to the standard C types (without
the @code{_t} suffix).

@emph{Note: these are not implemented yet. --luis}

@emph{I'm sure there are more of these that could be useful, let's
add any types that can't be defined portably to this list as
necessary. --james}

@ForeignType{:float}
@ForeignType{:double}

The @code{:float} type represents a C @code{float} and a Lisp
@code{single-float}. @code{:double} represents a C @code{double} and a
Lisp @code{double-float}.

@emph{Note: this is not true for Lispworks (on linux/x86 and win32 at
least). --luis}

@ForeignType{:pointer}

A foreign pointer to an object of any type, corresponding to
@code{void *}.

@ForeignType{:void}

No type at all. Only valid as the return type of a function.

@node Defining Typedefs
@section Defining Typedefs

@node Foreign Type Translators
@section Foreign Type Translators

Foo bar.

@node Foreign Structure Types
@section Foreign Structure Types

@subheading Foreign Structure Example

@c commented this out since it was causing confusion --luis

@c @lisp
@c ;; A hairy structure definition that illustrates some of the rules
@c ;; governing foreign structs.
@c (defcstruct (person :alignment :packed)
@c   "A person in the employee database."
@c   ;; the first argument after the name may be a docstring
@c   (id :int)
@c   ;; these are defined as char[255]'s in the c code
@c   (first-name  :char :count 255)
@c   (last-name   :char :count 255)
@c   ;; an embedded structure
@c   (birthdate timeval)
@c   ;; a pointer to another PERSON
@c   (supervisor :pointer))

@c ;;; If P is a pointer to a PERSON structure:

@c ;; This returns p->first_name, a pointer.
@c (foreign-slot-value p 'person 'first-name)

@c ;; This returns &p->birthdate, a pointer.
@c (foreign-slot-value p 'person 'birthdate)

@c ;; NOTE: this is not implemented yet.
@c ;; This returns p->birthdate.tv_secs as a Lisp integer.
@c (foreign-slot-value p 'person 'birthdate 'tv-secs)

@c ;; The previous form is equivalent to (but may be faster than):
@c (foreign-slot-value
@c  (foreign-slot-value p 'person 'birthdate) 'timeval 'tv-secs)

@c ;; Attempting to set the slot value of an embedded structure or
@c ;; embedded array causes an error.  Eventually, there may be a
@c ;; type converter that can handle this situation for some types.
@c ;; This would be: p->birthdate = ... in C.
@c (setf (foreign-slot-value p 'person 'timeval) ...) => error
@c @end lisp

@node Operations on Types
@section Operations on Types

@node Allocating Foreign Objects
@section Allocating Foreign Objects




@c ===================================================================
@c DEFCSTRUCT

@node defcstruct
@heading defcstruct
@subheading Syntax
@Macro{defcstruct name-and-options &body doc-and-slots => name}

name-and-options ::= structure-name | (structure-name &key size)

doc-and-slots ::= [docstring] @{ (slot-name slot-type &key count offset) @}*

@subheading Arguments and Values
@table @emph
@item structure-name
The name of new structure type.

@item docstring
A documentation string, ignored.

@item slot-name
A symbol naming the slot.

@item size
Use this option to override the size (in bytes) of the struct.

@item slot-type
The type specifier for the slot.

@item count
Used to declare an array of size @emph{count} inside the
structure.

@item offset
Overrides the slot's offset. The next slot's offset is calcultated
based on this one.
@end table

@subheading Description
A structure slot is either simple or aggregate.

Simple structure slots contain a single instance of a type that
canonicalizes to a built-in type, such as @code{:long} or
@code{:pointer}.

Aggregate slots contain an embedded structure or union, or an array
of objects.

@subheading Examples
@lisp
(defcstruct point
  "Pointer structure."
  (x :int)
  (y :int))

CFFI> (with-foreign-object (ptr 'point)
        ;; Initialize the slots
        (setf (foreign-slot-value ptr 'point 'x) 42
              (foreign-slot-value ptr 'point 'y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr point)
          (list x y)))
(42 42)
@end lisp

@lisp
;; Using the :size and :offset options to define a partial structure.
;; (this is useful when you are interested in only a few slots
;; of a big foreign structure)

(defcstruct (foo :size 32)
  "Some struct with 32 bytes."
                        ; <16 bytes we don't care about>
  (x :int :offset 16)   ; an int at offset 16
  (y :int)              ; another int at offset 16+sizeof(int)
                        ; <a couple more bytes we don't care about>
  (z :char :offset 24)  ; a char at offset 24
                        ; <7 more bytes ignored (since size is 32)>
  )

CFFI> (foreign-type-size 'foo)
32
@end lisp

@subheading See Also
@ref{foreign-slot-pointer} @*
@ref{foreign-slot-value} @*
@ref{with-foreign-slots}




@c ===================================================================
@c DEFCUNION

@node defcunion
@heading defcunion
@subheading Syntax
@Macro{defcunion name &body doc-and-slots => name}

doc-and-slots ::= [docstring] @{ (slot-name slot-type &key count) @}*

@subheading Arguments and Values
@table @emph
@item name
The name of new union type.

@item docstring
A documentation string, ignored.

@item slot-name
A symbol naming the slot.

@item slot-type
The type specifier for the slot.

@item count
Used to declare an array of size @emph{count} inside the
structure.
@end table

@subheading Description
A union is a structure in which all slots have an offset of
zero. Therefore, you should use the usual foreign structure operations
for accessing a union's slots.

@subheading Examples
@lisp
(defcunion uint32-bytes
  (int-value :unsigned-int)
  (bytes :unsigned-char :count 4))
@end lisp

@subheading See Also
@ref{foreign-slot-pointer} @*
@ref{foreign-slot-value}




@c ===================================================================
@c DEFCTYPE

@node defctype
@heading defctype
@subheading Syntax
@Macro{defctype name base-type &optional docstring}

@subheading Arguments and Values
@table @emph
@item name
The name of the new foreign type.

@item base-type
A symbol or a list defining the new type.

@item docstring
A documentation string, ignored.
@end table

@subheading Description
The @code{defctype} macro provides a mechanism similar to C's
@code{typedef} to define new types.

The new type inherits @emph{base-type}'s translators.

@subheading Examples
@lisp
(defctype my-string :string
  "My own string type.")

(defctype long-bools (:boolean :long)
  "Booleans that map to C longs.")
@end lisp

@subheading See Also
@ref{define-foreign-type} @*
@ref{define-type-translator}




@c ===================================================================
@c DEFCENUM

@node defcenum
@heading defcenum
@subheading Syntax
@Macro{defcenum name &body enum-list}

enum-list ::= [docstring] @{ keyword | (keyword value) @}*

@subheading Arguments and Values
@table @emph
@item name
The name of the new enum type.

@item docstring
A documentation string, ignored.

@item keyword
A keyword symbol.

@item value
An index value for a keyword.
@end table

@subheading Description
The @code{defcenum} macro is used to define foreign types that map
keyword symbols to integer values, similar to the C @code{enum} type.

If @emph{value} is omitted its value will either be 0, if it's the
first entry, or it it will continue the progression from the last
specified value.

Keywords will be automatically converted to values and vice-versa when
being passed as arguments to or returned from foreign functions,
respectively. The same applies to any other situations where an object
of an @code{enum} type is expected.

@subheading Examples
@lisp
(defcenum boolean
  :no
  :yes)

CFFI> (foreign-enum-value 'boolean :no)
0

(defcenum numbers
  (:one 1)
  :two
  (:four 4))

CFFI> (foreign-enum-keyword 'numbers 2)
:TWO
@end lisp

@subheading See Also
@ref{foreign-enum-value} @*
@ref{foreign-enum-keyword}




@c ===================================================================
@c DEFINE-TYPE-TRANSLATOR

@node define-type-translator
@heading define-type-translator
@subheading Syntax
@Macro{define-type-translator type direction arguments &body body}

arguments ::= (value-arg &optional var-arg body-arg)

@subheading Arguments and Values
@table @emph
@item type
A symbol naming a previously user-defined foreign type.

@item direction
One of @code{:to-c}, @code{:from-c} or @code{:to-c-dynamic}

@item type-arg
...

@item value-arg
...

@item var-arg
...

@item body-arg
...

@item body
The body of this type translator.
@end table

@subheading Description
@emph{TODO. For now check the examples.}

@subheading Examples
Here is how CFFI's @code{:boolean} type translator is defined:
@lisp
(define-type-translator :boolean :from-c (value) 
  "Type translator to convert t/nil to a C boolean."
  `(if ,value 1 0))

(define-type-translator :boolean :to-c (value)
  "Type translator to convert C booleans to t/nil."
  `(not (zerop ,value)))
@end lisp

And the @code{:string} type:

@lisp
(define-type-translator :string :to-c-dynamic (value var body)
  "Convert a lisp string to a foreign string with dynamic extent."
  `(with-foreign-string (,var ,value)
     ,@@body))

(define-type-translator :string :to-c (value)
  "Convert a lisp string to a foreign string."
  `(foreign-string-alloc ,value))

(define-type-translator :string :from-c (value)
  "Convert a foreign string to a lisp string."
  `(foreign-string-to-lisp ,value))
@end lisp

@subheading See Also
@ref{defctype} @*
@ref{define-foreign-type}



@c @c ===================================================================
@c @c DEFINE-TYPE-SPEC-PARSER

@c @node define-type-spec-parser
@c @heading define-type-spec-parser
@c @subheading Syntax

@c @subheading Arguments and Values
@c @table @emph
@c @item ...
@c asd

@c @item ...
@c asd
@c @end table

@c @subheading Description
@c @emph{Note: It doesn't make much sense for this macro to be exported
@c yet. --luis}

@c @subheading Examples
@c @subheading See Also




@c ===================================================================
@c DEFINE-FOREIGN-TYPE

@node define-foreign-type
@heading define-foreign-type
@subheading Syntax
@Macro{define-foreign-type type-name lambda-list &body body => type-name}

@subheading Arguments and Values
@table @emph
@item type-name
A symbol naming the new foreign type.

@item lambda-list
A lambda list which is the argument list of the new foreign type.

@item body
One or more forms that provide a definition of the new foreign type.
@end table

@subheading Description
The macro @code{define-foreign-type} defines a new parameterized type
called @emph{type-name}. Given the arguments specified in
@emph{lambda-list}, executing @emph{body} should return a type
specifier which will determine the behaviour of @emph{type-name}.
The behaviour of parameterized types can be further customized using
@code{define-type-translator}.

Unlike @code{defctype}, which is used to define simple C-like
typedefs, @code{define-foreign-type} provides a mechanism for type
aliases to take arguments. The following examples illustrate this
capability.

@subheading Examples
Taken from CFFI's @code{:boolean} type definition:
@lisp
(define-foreign-type :boolean (&optional (base-type :int))
  "Boolean type. Maps to an :int by default. Only accepts integer types."
  (ecase base-type
    ((:char
      :unsigned-char
      :int
      :unsigned-int
      :long
      :unsigned-long) base-type)))

CFFI> (canonicalize-foreign-type :boolean)
:INT
CFFI> (canonicalize-foreign-type '(:boolean :long))
:LONG
CFFI> (canonicalize-foreign-type '(:boolean :float))
; Error, signaled by ECASE.
@end lisp

This next example is hypothetical as there is no @code{:array} type
yet.
@lisp
(define-foreign-type int-array (&rest dimensions)
  `(:array :int ,@@dimensions))
@end lisp

@subheading See Also
@ref{defctype} @*
@ref{define-type-translator}




@c ===================================================================
@c EXPLAIN-FOREIGN-SLOT-VALUE

@node explain-foreign-slot-value
@heading explain-foreign-slot-value
@subheading Syntax
@Macro{explain-foreign-slot-value ptr type &rest slot-names}

@subheading Arguments and Values
@table @emph
@item ptr
...

@item type
...

@item slot-names
...
@end table

@subheading Description
This macro translates the slot access that would occur by calling
@code{foreign-slot-value} with the same arguments into an equivalent
expression in C and prints it to @code{*standard-output*}.

@emph{Note: this is not implemented yet.}

@subheading Examples
@lisp
CFFI> (explain-foreign-slot-value ptr 'timeval 'tv-secs)
ptr->tv_secs

CFFI> (explain-foreign-slot-value emp 'employee 'hire-date 'tv-usecs)
emp->hire_date.tv_usecs
@end lisp

@c @subheading See Also




@c ===================================================================
@c FOREIGN-ENUM-KEYWORD

@node foreign-enum-keyword
@heading foreign-enum-keyword
@subheading Syntax
@Function{foreign-enum-keyword type value => keyword}

@subheading Arguments and Values
@table @emph
@item type
An @code{enum} type.

@item value
An integer.

@item keyword
A keyword symbol.
@end table

@subheading Description
The function @code{foreign-enum-keyword} returns the keyword symbol
that corresponds to @emph{value} in @emph{type}.

An error is signaled if @emph{type} doesn't contain such @emph{value}.

@subheading Examples
@lisp
(defcenum boolean
  :no
  :yes)

CFFI> (foreign-enum-keyword 'boolean 1)
:YES
@end lisp
@subheading See Also
@ref{defcenum} @*
@ref{foreign-enum-value}




@c ===================================================================
@c FOREIGN-ENUM-VALUE

@node foreign-enum-value
@heading foreign-enum-value
@subheading Syntax
@Function{foreign-enum-value type keyword => value}

@subheading Arguments and Values
@table @emph
@item type
An @code{enum} type.

@item keyword
A keyword symbol.

@item value
An integer.
@end table

@subheading Description
The function @code{foreign-enum-keyword} returns the @emph{value} that
corresponds to @emph{keyword} in @emph{type}.

An error is signaled if @emph{type} doesn't contain such @emph{keyword}.

@subheading Examples
@lisp
(defcenum boolean
  :no
  :yes)

CFFI> (foreign-enum-keyword 'boolean :yes)
1
@end lisp

@subheading See Also
@ref{defcenum} @*
@ref{foreign-enum-keyword}




@c ===================================================================
@c FOREIGN-SLOT-NAMES

@node foreign-slot-names
@heading foreign-slot-names
@subheading Syntax
@Function{foreign-slot-names type => names}

@subheading Arguments and Values
@table @emph
@item type
A foreign struct type.

@item names
A list.
@end table

@subheading Description
The function @code{foreign-slot-names} returns a list of symbols that denote
the foreign slots of a struct type. This list has no particular order.

@subheading Examples
@lisp
(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI> (foreign-slot-names 'timeval)
(TV-SECS TV-USECS)
@end lisp

@subheading See Also
@ref{defcstruct} @*
@ref{foreign-slot-offset} @*
@ref{foreign-slot-value} @*
@ref{foreign-slot-pointer}




@c ===================================================================
@c FOREIGN-SLOT-OFFSET

@node foreign-slot-offset
@heading foreign-slot-offset
@subheading Syntax
@Function{foreign-slot-offset type slot-name => offset}

@subheading Arguments and Values
@table @emph
@item type
A foreign struct type.

@item slot-name
A symbol.

@item offset
An integer.
@end table

@subheading Description
The function @code{foreign-slot-offset} returns the @emph{offset} in
bytes of a slot in a foreign struct type.

@subheading Examples
@lisp
(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI> (foreign-slot-offset 'timeval 'tv-secs)
0
CFFI> (foreign-slot-offset 'timeval 'tv-usecs)
4
@end lisp

@subheading See Also
@ref{defcstruct} @*
@ref{foreign-slot-names} @*
@ref{foreign-slot-pointer} @*
@ref{foreign-slot-value}




@c ===================================================================
@c FOREIGN-SLOT-POINTER

@node foreign-slot-pointer
@heading foreign-slot-pointer
@subheading Syntax
@Function{foreign-slot-pointer ptr type &rest slot-names => pointer}

@subheading Arguments and Values
@table @emph
@item ptr
A pointer to structure.

@item type
A foreign structure type.

@item slot-names
One or more slot names.

@item pointer
A pointer to the slot specified in @emph{slot-names}.
@end table

@subheading Description
Returns a pointer to a slot referred by @emph{slot-names} in a foreign
object of type @emph{type} at @emph{ptr}. The returned pointer points
inside the structure. Both the pointer and the memory it points to
have the same extent as @emph{ptr}.

For aggregate slots, this is the same value returned by
@code{foreign-slot-value}.

@subheading Examples
@lisp
(defcstruct point
  "Pointer structure."
  (x :int)
  (y :int))

CFFI> (with-foreign-object (ptr 'point)
        (foreign-slot-pointer ptr 'point 'x))
#<FOREIGN-ADDRESS #xBFFF6E60>
;; Note: the exact pointer representation varies from lisp to lisp.
@end lisp

@subheading See Also
@ref{defcstruct} @*
@ref{foreign-slot-value} @*
@ref{foreign-slot-names} @*
@ref{foreign-slot-offset}




@c ===================================================================
@c FOREIGN-SLOT-VALUE

@node foreign-slot-value
@heading foreign-slot-value
@subheading Syntax
@Accessor{foreign-slot-value ptr type &rest slot-names => object}

@subheading Arguments and Values
@table @emph
@item ptr
A pointer to structure.

@item type
A foreign structure type.

@item slot-names
One or more slot names.

@item object
The object contained in the slot specified in @emph{slot-names}.
@end table

@subheading Description
For simple slots, @code{foreign-slot-value} returns the value of the
object, such as a Lisp integer or pointer. In C, this would be
expressed as @code{ptr->slot}.

For aggregate slots, a pointer inside the structure to the beginning
of the slot's data is returned. In C, this would be expressed as
@code{&ptr->slot}. This pointer and the memory it points to have the
same extent as @emph{ptr}.

There are compiler macros for @code{foreign-slot-value} and its
@code{setf} expansion that open code the memory access when 
@emph{type} and @emph{slot-names} are constant at compile-time.

@subheading Examples
@lisp
(defcstruct point
  "Pointer structure."
  (x :int)
  (y :int))

CFFI> (with-foreign-object (ptr 'point)
        ;; Initialize the slots
        (setf (foreign-slot-value ptr 'point 'x) 42
              (foreign-slot-value ptr 'point 'y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr point)
          (list x y)))
(42 42)
@end lisp

@subheading See Also
@ref{defcstruct} @*
@ref{foreign-slot-names} @*
@ref{foreign-slot-offset} @*
@ref{foreign-slot-pointer} @*
@ref{with-foreign-slots}




@c ===================================================================
@c FOREIGN-TYPE-ALIGNMENT

@node foreign-type-alignment
@heading foreign-type-alignment
@subheading Syntax
@c XXX: This is actually a generic function.
@Function{foreign-type-alignment type => alignment}

@subheading Arguments and Values
@table @emph
@item type
A foreign type.

@item alignment
An integer.
@end table

@subheading Description
The function @code{foreign-type-alignment} returns the
@emph{alignment} of @emph{type} in bytes.

@subheading Examples
@lisp
CFFI> (foreign-type-alignment :char)
1
CFFI> (foreign-type-alignment :short)
2
CFFI> (foreign-type-alignment :int)
4

(defcstruct foo
  (a :char))

CFFI> (foreign-type-alignment 'foo)
1
@end lisp

@subheading See Also
@ref{foreign-type-size}




@c ===================================================================
@c FOREIGN-TYPE-SIZE

@node foreign-type-size
@heading foreign-type-size
@subheading Syntax
@c XXX: this is actually a generic function.
@Function{foreign-type-size type => size}

@subheading Arguments and Values
@table @emph
@item type
A foreign type.

@item size
An integer.
@end table

@subheading Description
The function @code{foreign-type-size} return the @emph{size} of
@emph{type} in bytes.

@subheading Examples
@lisp
(defcstruct foo
  (a :double)
  (c :char))

CFFI> (foreign-type-size :double)
8
CFFI> (foreign-type-size :char)
1
CFFI> (foreign-type-size 'foo)
12
@end lisp

@subheading See Also
@ref{foreign-type-alignment}




@c ===================================================================
@c WITH-FOREIGN-OBJECT

@node with-foreign-object
@heading with-foreign-object
@subheading Syntax
@Macro{with-foreign-object (var type &optional count) &body body}

@Macro{with-foreign-objects (bindings) &body body}

bindings = @{(var type &optional count)@}*

@subheading Arguments and Values
@table @emph
@item var
A symbol.

@item type
A foreign type, evaluated.

@item count
An integer.
@end table

@subheading Description
The macros @code{with-foreign-object} and @code{with-foreign-objects}
bind @emph{var} to a pointer to @emph{count} newly allocated objects
of type @emph{type} during @emph{body}. The buffer has dynamic extent
and may be stack allocated if supported by the host Lisp.

@subheading Examples
@lisp
CFFI> (with-foreign-object (array :int 10)
        (loop for i below 10
              do (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10 collect (mem-aref array :int i)))
(22 7 22 52 69 1 46 93 90 65)
@end lisp

@subheading See Also
@ref{foreign-alloc}




@c ===================================================================
@c WITH-FOREIGN-SLOTS

@node with-foreign-slots
@heading with-foreign-slots
@subheading Syntax
@Macro{with-foreign-slots (vars ptr type) &body body}

@subheading Arguments and Values
@table @emph
@item vars
A list of symbols.

@item ptr
A foreign pointer to a structure.

@item type
A structure type.

@item body
A list of forms to be executed.
@end table

@subheading Description
The @code{with-foreign-slots} macro creates local symbol macros for
each var in @emph{vars} to reference foreign slots in @emph{ptr} of
@emph{type}. It is similar to Common Lisp's @code{with-slots} macro.

@subheading Examples
@lisp
(defcstruct tm
  (sec :int)
  (min :int)
  (hour :int)
  (mday :int)
  (mon  :int)
  (year :int)
  (wday :int)
  (yday :int)
  (isdst  :boolean)
  (zone   :string)
  (gmtoff :long))

CFFI> (with-foreign-object (time :int)
        (setf (mem-ref time :int)
              (foreign-funcall "time" :pointer (null-pointer) :int))
        (foreign-funcall "gmtime" :pointer time tm))
#<A Mac Pointer #x102A30>
CFFI> (with-foreign-slots ((sec min hour mday mon year) * tm)
        (format nil "~A:~A:~A, ~A/~A/~A" hour min sec (+ 1900 year) mon mday))
"7:22:47, 2005/8/2"
@end lisp

@subheading See Also
@ref{defcstruct} @*
@ref{defcunion} @*
@ref{foreign-slot-value}




@c ===================================================================
@c CHAPTER: Pointers

@node Pointers
@chapter Pointers

@emph{Describe the theory of how foreign variables work---they are
always pointers, even when accessing integer types or embedded
structures. You cannot represent a structure by value.}

@menu
* Basic Pointer Operations::    
* Allocating Foreign Memory::   
* Accessing Foreign Memory::    

Dictionary

* foreign-free::                
* foreign-alloc::               
* foreign-symbol-pointer::      
* inc-pointer::                 
* make-pointer::                
* mem-aref::                    
* mem-ref::                     
* null-pointer::                
* null-pointer-p::              
* pointerp::                    
* pointer-address::             
* pointer-eq::                  
* with-foreign-pointer::        
@end menu

@node Basic Pointer Operations
@section Basic Pointer Operations

@node Allocating Foreign Memory
@section Allocating Foreign Memory

@node Accessing Foreign Memory
@section Accessing Foreign Memory




@c ===================================================================
@c FOREIGN-FREE

@node foreign-free
@heading foreign-free
@subheading Syntax
@Function{foreign-free ptr => undefined}

@subheading Arguments and Values
@table @emph
@item ptr
A foreign pointer.
@end table

@subheading Description
The @code{foreign-free} function frees a @code{ptr} previously
allocated by @code{foreign-alloc}. The consequences of freeing a given
pointer twice are undefined.

@subheading Examples
@lisp
CFFI> (foreign-alloc :int)
#<A Mac Pointer #x1022E0>
CFFI> (foreign-free *)
NIL
@end lisp

@subheading See Also
@ref{foreign-alloc} @*
@ref{with-foreign-pointer}




@c ===================================================================
@c FOREIGN-ALLOC

@node foreign-alloc
@heading foreign-alloc
@subheading Syntax
@Function{foreign-alloc type &key initial-element initial-contents
                        (count 1) => pointer}

@subheading Arguments and Values
@table @emph
@item type
A foreign type.

@item initial-element
A Lisp object.

@item initial-contents
A sequence.

@item count
An integer bigger than or equal to 1. 1, by default.

@item pointer
A foreign pointer to the newly allocated memory.
@end table

@subheading Description
The @code{foreign-alloc} function allocates enough memory to hold
@emph{count} objects of type @emph{type} and returns a
@emph{pointer}. This memory must be explicitly freed using
@code{foreign-free} once it is no longer needed.

If @emph{initial-element} is supplied, it is used to initialize the
@emph{count} objects the newly allocated memory holds.

If an @emph{initial-contents} sequence is supplied, it must have a
length less than or equal to @emph{count} and each of its elements
will be used to initialize the contents of the newly allocated
memory.

@emph{initial-element} and @emph{initial-contents} are mutually
exclusive.

@subheading Examples
@lisp
CFFI> (foreign-alloc :char)
#<A Mac Pointer #x1022E0>     ; A pointer to 1 byte of memory.

CFFI> (foreign-alloc :char :count 20)
#<A Mac Pointer #x1022E0>     ; A pointer to 20 bytes of memory.

CFFI> (foreign-alloc :int :initial-element 12)
#<A Mac Pointer #x1022E0>
CFFI> (mem-ref * :int)
12

CFFI> (foreign-alloc :int :initial-contents '(1 2 3))
#<A Mac Pointer #x1022E0>
CFFI> (loop for i from 0 below 3
            collect (mem-ref * :int i))
(1 2 3)

CFFI> (foreign-alloc :int :initial-contents #(1 2 3))
#<A Mac Pointer #x1022E0>
CFFI> (loop for i from 0 below 3
            collect (mem-ref * :int i))
(1 2 3)

CFFI> (foreign-alloc :string :initial-element "foo")
#<A Mac Pointer #x1022E0>
;; This will actually allocate a char** pointer that points
;; to newly allocated memory by the :string type translator
;; for the "foo" string.
@end lisp

@subheading See Also
@ref{foreign-free} @*
@ref{with-foreign-pointer}




@c ===================================================================
@c FOREIGN-SYMBOL-POINTER

@node foreign-symbol-pointer
@heading foreign-symbol-pointer
@subheading Syntax
@Function{foreign-symbol-pointer foreign-name kind => ptr}

@subheading Arguments and Values
@table @emph
@item foreign-name
A string.

@item kind
Either @code{:code} or @code{:data}.

@item ptr
A foreign pointer, or @code{nil}.
@end table

@subheading Description
The function @code{foreign-symbol-pointer} will return a foreign
pointer corresponding to the foreign symbol denoted by the string
@emph{foreign-name}. The @emph{kind} argument specifies whether
@emph{foreign-name} is a function or a variable and should be
respectively @code{:code} or @code{:data}. If a foreign symbol named
@emph{foreign-name} doesn't exist, @code{nil} is returned.

ABI name manglings will be performed on @emph{foreign-name} by
@code{foreign-symbol-pointer} if necessary. (eg: adding a leading
underscore on darwin/ppc)

@strong{Warning:} the consequences of misspecifying the @emph{kind}
argument are, unfortunately, unspecified. Some implementations will
silently ignore this, while others might return erroneous values.

@subheading Examples
@lisp
CFFI> (foreign-symbol-pointer "errno" :data)
#<A Mac Pointer #xA0008130>
CFFI> (foreign-symbol-pointer "strerror" :code)
#<A Mac Pointer #x9002D0F8>
CFFI> (foreign-funcall * :int (mem-ref ** :int) :string)
"No such file or directory"

CFFI> (foreign-symbol-pointer "unexistant symbol" :data)
NIL
@end lisp

@subheading See Also
@ref{defcvar}




@c ===================================================================
@c INC-POINTER

@node inc-pointer
@heading inc-pointer
@subheading Syntax
@Function{inc-pointer ptr offset => new-pointer}

@subheading Arguments and Values
@table @emph
@item ptr, new-pointer
A foreign pointer.

@item offset
An integer.
@end table

@subheading Description
The function @code{inc-pointer} will return a @emph{new-pointer} pointing
@emph{offset} bytes past @emph{ptr}.

@subheading Examples
@lisp
CFFI> (foreign-string-alloc "Common Lisp")
#<A Mac Pointer #x102EA0>
CFFI> (inc-pointer * 7)
#<A Mac Pointer #x102EA7>
CFFI> (foreign-string-to-lisp *)
"Lisp"
@end lisp

@subheading See Also
@ref{make-pointer} @*
@ref{pointerp} @*
@ref{null-pointer} @*
@ref{null-pointer-p}




@c ===================================================================
@c MAKE-POINTER

@node make-pointer
@heading make-pointer
@subheading Syntax
@Function{make-pointer address => ptr}

@subheading Arguments and Values
@table @emph
@item address
An integer.

@item ptr
A foreign pointer.
@end table

@subheading Description
The function @code{make-pointer} will return a foreign pointer
pointing to @emph{address}.

@subheading Examples
@lisp
CFFI> (make-pointer 42)
#<FOREIGN-ADDRESS #x0000002A>
CFFI> (pointerp *)
T
CFFI> (pointer-adress **)
42
CFFI> (inc-pointer *** -42)
#<FOREIGN-ADDRESS #x00000000>
CFFI> (null-pointer-p *)
T
@end lisp

@subheading See Also
@ref{inc-pointer} @*
@ref{null-pointer} @*
@ref{null-pointer-p} @*
@ref{pointerp} @*
@ref{pointer-address} @*
@ref{pointer-eq} @*
@ref{mem-ref}




@c ===================================================================
@c MEM-AREF

@node mem-aref
@heading mem-aref
@subheading Syntax
@Accessor{mem-aref ptr type &optional (index 0)}

(setf (@strong{mem-aref} @emph{ptr type &optional (index 0)) new-value})

@subheading Arguments and Values
@table @emph
@item ptr
A foreign pointer.

@item type
A foreign type.

@item index
An integer.

@item new-value
A Lisp value compatible with @emph{type}.
@end table

@subheading Description
The @code{mem-aref} function is similar to @code{mem-ref} but will
automatically calculate the offset from an @emph{index}.

@lisp
(mem-aref ptr type n)

;; is identical to:

(mem-ref ptr type (* n (foreign-type-size type)))
@end lisp

@subheading Examples
@lisp
CFFI> (with-foreign-string (str "Hello, foreign world!")
        (mem-aref str :char 6))
32
CFFI> (code-char *)
#\Space

CFFI> (with-foreign-object (array :int 10)
        (loop for i below 10
              do (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10 collect (mem-aref array :int i)))
(22 7 22 52 69 1 46 93 90 65)
@end lisp

@subheading See Also
@ref{mem-ref}




@c ===================================================================
@c MEM-REF

@node mem-ref
@heading mem-ref
@subheading Syntax
@Accessor{mem-ref ptr type &optional offset => object}

@subheading Arguments and Values
@table @emph
@item ptr
A pointer.

@item type
A foreign type.

@item offset
An integer (in byte units).

@item object
The value @emph{ptr} points to.
@end table

@subheading Description
@subheading Examples
@lisp
CFFI> (with-foreign-string (ptr "Saluton")
        (setf (mem-ref ptr :char 3) (char-code #\a))
        (loop for i from 0 below 8
              collect (code-char (mem-ref ptr :char i))))
(#\S #\a #\l #\a #\t #\o #\n #\Null)

CFFI> (setq ptr-to-int (foreign-alloc :int))
#<A Mac Pointer #x1047D0>
CFFI> (mem-ref ptr-to-int :int)
1054619
CFFI> (setf (mem-ref ptr-to-int :int) 1984)
1984
CFFI> (mem-ref ptr-to-int :int)
1984
@end lisp

@subheading See Also
@ref{mem-aref}




@c ===================================================================
@c NULL-POINTER

@node null-pointer
@heading null-pointer
@subheading Syntax
@Function{null-pointer => pointer}

@subheading Arguments and Values
@table @emph
@item pointer
A @code{NULL} pointer.
@end table

@subheading Description
The function @code{null-pointer} returns a null pointer.

@subheading Examples
@lisp
CFFI> (null-pointer)
#<A Null Mac Pointer>
CFFI> (pointerp *)
T
@end lisp

@subheading See Also
@ref{null-pointer-p} @*
@ref{make-pointer}




@c ===================================================================
@c NULL-POINTER-P

@node null-pointer-p
@heading null-pointer-p
@subheading Syntax
@Function{null-pointer-p ptr => boolean}

@subheading Arguments and Values
@table @emph
@item ptr
A foreign pointer that may be a null pointer.

@item boolean
@code{T} or @code{NIL}.
@end table

@subheading Description
The function @code{null-pointer-p} returns true if @emph{ptr} is a null
pointer and false otherwise.

@subheading Examples
@lisp
CFFI> (null-pointer-p (null-pointer))
T

(defun contains-str-p (big little)
  (not (null-pointer-p
        (foreign-funcall "strstr" :string big :string little :pointer))))

CFFI> (contains-str-p "Popcorns" "corn")
T
CFFI> (contains-str-p "Popcorns" "salt")
NIL
@end lisp

@subheading See Also
@ref{null-pointer} @*
@ref{pointerp}




@c ===================================================================
@c POINTERP

@node pointerp
@heading pointerp
@subheading Syntax
@Function{pointerp ptr => boolean}

@subheading Arguments and Values
@table @emph
@item ptr
An object that may be a foreign pointer.

@item boolean
@code{T} or @code{NIL}.
@end table

@subheading Description
The function @code{pointerp} returns true if @emph{ptr} is a foreign
pointer and false otherwise.

@subheading Implementation-specific Notes
In Allegro CL, foreign pointers are integers thus in this
implementation @code{pointerp} will return true for any ordinary integer.

@subheading Examples
@lisp
CFFI> (foreign-alloc 32)
#<A Mac Pointer #x102D20>
CFFI> (pointerp *)
T
CFFI> (pointerp "this is not a pointer")
NIL
@end lisp

@subheading See Also
@ref{make-pointer}
@ref{null-pointer-p}



@c ===================================================================
@c POINTER-ADDRESS

@node pointer-address
@heading pointer-address
@subheading Syntax
@Function{pointer-address ptr => address}

@subheading Arguments and Values
@table @emph
@item ptr
A foreign pointer.

@item address
An integer.
@end table

@subheading Description
The function @code{pointer-address} will return the @emph{address} of
a foreign pointer @emph{ptr}.

@subheading Examples
@lisp
CFFI> (pointer-address (null-pointer))
0
CFFI> (pointer-address (make-pointer 123))
123
@end lisp

@subheading See Also
@ref{make-pointer} @*
@ref{inc-pointer} @*
@ref{null-pointer} @*
@ref{null-pointer-p} @*
@ref{pointerp} @*
@ref{pointer-eq} @*
@ref{mem-ref}




@c ===================================================================
@c POINTER-EQ

@node pointer-eq
@heading pointer-eq
@subheading Syntax
@Function{pointer-eq ptr1 ptr2 => boolean}

@subheading Arguments and Values
@table @emph
@item ptr1, ptr2
A foreign pointer.

@item boolean
@code{T} or @code{NIL}.
@end table

@subheading Description
The function @code{pointer-eq} returns true if @emph{ptr1} and
@emph{ptr2} point to the same memory address and false otherwise.

@subheading Implementation-specific Notes
The representation of foreign pointers varies across the various Lisp
implementations as does the behaviour of the built-in Common Lisp
equality predicates. Comparing two pointers that point to the same
address with @code{EQ} Lisps will return true on some Lisps, others require
more general predicates like @code{EQL} or @code{EQUALP} and finally
some will return false using any of these predicates. Therefore, for
portability, you should use @code{POINTER-EQ}.

@subheading Examples
This is an example using SBCL, see the implementation-specific notes
above.
@lisp
CFFI> (eql (null-pointer) (null-pointer))
NIL
CFFI> (pointer-eq (null-pointer) (null-pointer))
T
@end lisp

@subheading See Also
@ref{inc-pointer}




@c ===================================================================
@c WITH-FOREIGN-POINTER

@node with-foreign-pointer
@heading with-foreign-pointer
@subheading Syntax
@Macro{with-foreign-pointer (var size &optional size-var) &body body}

@subheading Arguments and Values
@table @emph
@item var, size-var
A symbol.

@item size
An integer.

@item body
A list of forms to be executed.
@end table

@subheading Description
The @code{with-foreign-pointer} macro, binds @emph{var} to @emph{size}
bytes of foreign memory during @emph{body}. The pointer in @emph{var}
is invalid beyond the dynamic extend of @emph{body} and may be
stack-allocated if supported by the implementation.

If @emph{size-var} is supplied, it will be bound to @emph{size} during
@emph{body}.

@subheading Examples
@lisp
CFFI> (with-foreign-pointer (string 4 size)
        (setf (mem-ref string :char (1- size)) 0)
        (lisp-string-to-foreign "Popcorns" string size)
        (loop for i from 0 below size
              collect (code-char (mem-ref string :char i))))
(#\P #\o #\p #\Null)
@end lisp

@subheading See Also
@ref{foreign-alloc} @*
@ref{foreign-free}




@c ===================================================================
@c CHAPTER: Strings

@node Strings
@chapter Strings

@menu
Dictionary

* foreign-string-alloc::        
* foreign-string-free::         
* foreign-string-to-lisp::      
* lisp-string-to-foreign::      
* with-foreign-string::         
* with-foreign-pointer-as-string::  
@end menu




@c ===================================================================
@c FOREIGN-STRING-ALLOC

@node foreign-string-alloc
@heading foreign-string-alloc
@subheading Syntax
@Function{foreign-string-alloc string => pointer}

@subheading Arguments and Values
@table @emph
@item string
A Lisp string.

@item pointer
A pointer to the newly allocated foreign string containg @emph{string}.
@end table

@subheading Description
The @code{foreign-string-alloc} function allocates a foreign string
containing a Lisp @emph{string}.

This string must be freed with @code{foreign-string-free}.

@subheading Examples
@lisp
CFFI> (setq str (foreign-string-alloc "Hello, foreign world!"))
#<FOREIGN-ADDRESS #x00400560>
CFFI> (foreign-funcall "strlen" :pointer str :int)
21
@end lisp

@subheading See Also
@ref{foreign-string-free} @*
@ref{with-foreign-string}
@c @ref{:string}




@c ===================================================================
@c FOREIGN-STRING-FREE

@node foreign-string-free
@heading foreign-string-free
@subheading Syntax
@Function{foreign-string-free pointer}

@subheading Arguments and Values
@table @emph
@item pointer
A pointer to string allocated by @code{foreign-string-alloc}.
@end table

@subheading Description
The @code{foreign-string-free} function frees a foreign string
allocated by @code{foreign-string-alloc}.

@subheading Examples

@subheading See Also
@ref{foreign-string-alloc}



@c ===================================================================
@c FOREIGN-STRING-TO-LISP

@node foreign-string-to-lisp
@heading foreign-string-to-lisp
@subheading Syntax
@Function{foreign-string-to-lisp ptr &optional size null-terminated-p
=> string}

@subheading Arguments and Values
@table @emph
@item ptr
A pointer.

@item size
The maximum string size. @code{most-positive-fixnum}, by default.

@item null-terminated-p
Specifies if the string @emph{ptr} points to is null terminated. True,
by default.
@end table

@subheading Description
The @code{foreign-string-to-lisp} function copies at most @emph{size}
characters from @emph{ptr} into a Lisp string.

When @emph{null-terminated-p} is true (the default), characters are
copied until @emph{size} is reached or a @code{NULL} character is
found.

If @emph{ptr} is a null pointer, returns nil.

Note that the @code{:string} type will automatically convert between
Lisp strings and foreign strings.

@subheading Examples
@lisp
CFFI> (foreign-funcall "getenv" :string "HOME" :pointer)
#<FOREIGN-ADDRESS #xBFFFFFD5>
CFFI> (foreign-string-to-lisp *)
"/Users/luis"
@end lisp

@subheading See Also
@ref{foreign-string-to-lisp}




@c ===================================================================
@c LISP-STRING-TO-FOREIGN

@node lisp-string-to-foreign
@heading lisp-string-to-foreign
@subheading Syntax
@Function{lisp-string-to-foreign string ptr size}

@subheading Arguments and Values
@table @emph
@item string
A Lisp string.

@item ptr
A foreign pointer.

@item size
An integer.
@end table

@subheading Description
The @code{lisp-string-to-foreign} function copies at most
@emph{size}-1 characters from a Lisp @emph{string} to @emph{ptr}. The
foreign string will be null-terminated.

@subheading Examples
@lisp
CFFI> (with-foreign-pointer-as-string (str 255)
        (lisp-string-to-foreign "Hello, foreign world!" str 6))
"Hello"
@end lisp

@subheading See Also
@ref{foreign-string-alloc} @*
@ref{foreign-string-to-lisp} @*
@ref{with-foreign-pointer-as-string}




@c ===================================================================
@c WITH-FOREIGN-STRING

@node with-foreign-string
@heading with-foreign-string
@subheading Syntax
@Macro{with-foreign-string (var lisp-string) &body body}

@subheading Arguments and Values
@table @emph
@item var
A symbol.

@item lisp-string
A Lisp string.

@item body
A list of forms to be executed.
@end table

@subheading Description
The @code{with-foreign-string} macro will bind @emph{var} to a newly
allocated foreign string containing @emph{lisp-string}.

@subheading Examples
@lisp
CFFI> (with-foreign-string (foo "12345")
        (foreign-funcall "strlen" :pointer foo :int))
5
@end lisp

@subheading See Also
@ref{foreign-string-alloc} @*
@ref{with-foreign-pointer-as-string}




@c ===================================================================
@c WITH-FOREIGN-POINTER-AS-STRING

@node with-foreign-pointer-as-string
@heading with-foreign-pointer-as-string
@subheading Syntax
@Macro{with-foreign-pointer-as-string (var size &optional size-var) &body body}

@subheading Arguments and Values
@table @emph
@item var
A symbol.

@item lisp-string
A Lisp string.

@item body
List of forms to be executed.
@end table

@subheading Description
The @code{with-foreign-pointer-as-string} macro is similar to
@code{with-foreign-pointer} except that @emph{var}, as a Lisp string, is
used as the returned value of an implicit @code{progn} around @emph{body}.

@subheading Examples
@lisp
CFFI> (with-foreign-pointer-as-string (str 6 str-size)
        (lisp-string-to-foreign "Hello, foreign world!" str str-size))
"Hello"
@end lisp

@subheading See Also
@ref{foreign-string-alloc} @*
@ref{with-foreign-string}




@c ===================================================================
@c CHAPTER: Variables

@node Variables
@chapter Variables

@menu
Dictionary

* defcvar::                     
* get-var-pointer::                 
@end menu




@c ===================================================================
@c DEFCVAR

@node defcvar
@heading defcvar
@subheading Syntax
@Macro{defcvar name type &key read-only => lisp-name}

name ::= lisp-name | foreign-name | (foreign-name lisp-name)

@subheading Arguments and Values
@table @emph
@item foreign-name
A string denoting a foreign function.

@item lisp-name
A symbol naming the Lisp function to be created.

@item type
A foreign type.

@item read-only
A boolean.
@end table

@subheading Description
The @code{defcvar} macro 

When one of @emph{lisp-name} or @emph{foreign-name} is omitted, the
other is automatically derived using the following rules:

@itemize
@item
Foreign names are converted to Lisp names by uppercasing, replacing
underscores with hyphens, and wrapping around asterisks.
@item
Lisp names are converted to foreign names by lowercasing, replacing
hyphens with underscores, and removing asterisks, if any.
@end itemize

@subheading Examples
@lisp
CFFI> (defcvar "errno" :int)
*ERRNO*
CFFI> (foreign-funcall "strerror" :int *errno* :string)
"Inappropriate ioctl for device"
CFFI> (setf *errno* 1)
1
CFFI> (foreign-funcall "strerror" :int *errno* :string)
"Operation not permitted"
@end lisp

Trying to modify a read-only foreign variable:

@lisp
CFFI> (defcvar ("errno" +error-number+) :int :read-only t)
+ERROR-NUMBER+
CFFI> (setf +error-number+ 12)
; Error: Trying to modify read-only foreign var: +ERROR-NUMBER+.
@end lisp

@emph{Note that accessing @code{errno} this way won't work with every
C standard library.}

@subheading See Also
@ref{get-var-pointer}




@c ===================================================================
@c GET-VAR-POINTER

@node get-var-pointer
@heading get-var-pointer
@subheading Syntax
@Function{get-var-pointer symbol => pointer}

@subheading Arguments and Values
@table @emph
@item symbol
A symbol denoting a foreign variable defined with @code{defcvar}.

@item pointer
A foreign pointer.
@end table

@subheading Description
The function @code{get-var-pointer} will return a @emph{pointer} to the
foreign global variable @emph{symbol} previously defined with
@code{defcvar}.

@subheading Examples
@lisp
CFFI> (defcvar "errno" :int :read-only t)
*ERRNO*
CFFI> *errno*
25
CFFI> (get-var-pointer '*errno*)
#<A Mac Pointer #xA0008130>
CFFI> (mem-ref * :int)
25
@end lisp

@subheading See Also
@ref{defcvar}




@c ===================================================================
@c CHAPTER: Functions

@node Functions
@chapter Functions

@menu
* Calling Foreign Functions::   
* Defining Foreign Functions::  

Dictionary

* defcfun::                     
* foreign-funcall::             
@end menu

@node Calling Foreign Functions
@section Calling Foreign Functions

@node Defining Foreign Functions
@section Defining Foreign Functions




@c ===================================================================
@c DEFCFUN

@node defcfun
@heading defcfun
@subheading Syntax
@Macro{defcfun name return-type &body arguments => lisp-name}

name ::= lisp-name | foreign-name | (foreign-name lisp-name) @*
arguments ::= @{ (arg-name arg-type) @}*

@subheading Arguments and Values
@table @emph
@item foreign-name
A string denoting a foreign function.

@item lisp-name
A symbol naming the Lisp function to be created.

@item arg-name
A symbol.

@item return-type, arg-type
A foreign type.
@end table

@subheading Description
The @code{defcfun} macro provides a declarative interface for defining
Lisp functions that call foreign functions.

When one of @emph{lisp-name} or @emph{foreign-name} is omitted, the
other is automatically derived using the following rules:

@itemize
@item
Foreign names are converted to Lisp names by uppercasing and replacing
underscores with hyphens.
@item
Lisp names are converted to foreign names by lowercasing and replacing
hyphens with underscores.
@end itemize

@subheading Examples
@lisp
(defcfun "strlen" :int (n :string))

CFFI> (strlen "123")
3

(defcfun ("abs" c-abs) :int (n :int))

CFFI> (c-abs -42)
42
@end lisp

@subheading See Also
@ref{foreign-funcall}




@c ===================================================================
@c FOREIGN-FUNCALL

@node foreign-funcall
@heading foreign-funcall
@subheading Syntax
@Macro{foreign-funcall name-or-pointer &rest arguments => return-value}

arguments ::= @{ arg-type arg @}* [return-type] 

@subheading Arguments and Values
@table @emph
@item name-or-pointer
Either a string or a pointer.

@item arg-type
A foreign type.

@item arg
An argument of type @emph{arg-type}.

@item return-type
A foreign type, @code{:void} by default.

@item return-value
A lisp object.
@end table

@subheading Description
The @code{foreign-funcall} macro is the main primitive for calling
foreign functions.

@emph{Note: The return value of foreign-funcall on functions with a
:void return type is still undefined.}

@subheading Implementation-specific Notes
@itemize
@item
Lispworks and Corman Lisp do not support @code{foreign-funcall}. In
these implementations, @code{:no-foreign-funcall} will be present in
@code{*features*}. Note: in these Lisps you can still use
@code{defcfun} interface.
@end itemize

@subheading Examples
@lisp
CFFI> (foreign-funcall "strlen" :string "foo" :int)
3
@end lisp

@lisp
;; void print_number(int n)
;; @{
;;     printf("N: %d\n", n);
;; @}

CFFI> (foreign-funcall "print_number" :int 123456)
N: 123456
NIL

;; Or, equivalently:
CFFI> (foreign-funcall "print_number" :int 123456 :void)
N: 123456
NIL
@end lisp

@lisp
CFFI> (foreign-funcall "printf" :string (format nil "%s: %d.~%")
                       :string "So long and thanks for all the fish"
                       :int 42 :int)
So long and thanks for all the fish: 42.
41
@end lisp

@subheading See Also
@ref{defcfun}




@c ===================================================================
@c CHAPTER: Libraries

@node Libraries
@chapter Libraries

@menu
Dictionary

* load-foreign-library::        
@end menu




@c ===================================================================
@c LOAD-FOREIGN-LIBRARY

@node load-foreign-library
@heading load-foreign-library
@subheading Syntax
@Function{load-foreign-library name}

@subheading Arguments and Values
@table @emph
@item name
...
@end table

@subheading Description
@emph{For now, this interface is dirt simple. It simply passes the
library name to the underlying function in CFFI-SYS. Once we get some
user feedback about implementing a search strategy this will get
fancier. --james}

@subheading Examples
@subheading See Also




@c ===================================================================
@c CHAPTER: Callbacks

@node Callbacks
@chapter Callbacks

@menu
Dictionary

* callback::                    
* defcallback::                 
* get-callback::                
@end menu




@c ===================================================================
@c CALLBACK

@node callback
@heading callback
@subheading Syntax
@Macro{callback symbol => pointer}

(setf (@strong{callback} @emph{symbol) new-value})

@subheading Arguments and Values
@table @emph
@item symbol
A symbol denoting a callback.

@item pointer, new-value
A pointer.
@end table

@subheading Description
The @code{callback} macro is analogous to the standard CL special
operator @code{function} and will return a pointer to the callback
denoted by the symbol @emph{name}.

@subheading Examples
@lisp
CFFI> (defcallback sum :int ((a :int) (b :int))
        (+ a b))
SUM
CFFI> (callback sum)
#<A Mac Pointer #x102350>
CFFI> (setf (callback sum) (null-pointer))
#<A Null Mac Pointer>
CFFI> (callback sum)
#<A Null Mac Pointer>
@end lisp

@subheading See Also
@ref{get-callback} @*
@ref{defcallback}




@c ===================================================================
@c DEFCALLBACK

@node defcallback
@heading defcallback
@subheading Syntax
@Macro{defcallback name return-type arguments &body body => name}

arguments ::= (@{ (arg-name arg-type) @}*)

@subheading Arguments and Values
@table @emph
@item name
A symbol naming the callback created.

@item return-type
The foreign type for the callback's return value.

@item arg-name
A symbol.

@item arg-type
A foreign type.
@end table

@subheading Description
The macro @code{defcallback} defines a Lisp function the can be called
from C (but not from Lisp). The arguments passed to this function will
be converted to the appropriate Lisp representation and its return
value will be converted to its C representation.

This Lisp function can be accessed by the @code{callback} macro or the
@code{get-callback} function.

@subheading Examples
@lisp
(defcfun "qsort" :void
  (base :pointer)
  (nmemb :int)
  (size :int)
  (fun-compar :pointer))

(defcallback < :int ((a :pointer) (b :pointer))
  (let ((x (mem-ref a :int))
        (y (mem-ref b :int)))
    (cond ((> x y) 1)
          ((< x y) -1)
          (t 0))))

CFFI> (with-foreign-object (array :int 10)
        ;; Initialize array.
        (loop for i from 0 and n in '(7 2 10 4 3 5 1 6 9 8)
              do (setf (mem-aref array :int i) n))
        ;; Sort it.
        (qsort array 10 (foreign-type-size :int) (callback <))
        ;; Return it as a list.
        (loop for i from 0 below 10
              collect (mem-aref array :int i)))
(1 2 3 4 5 6 7 8 9 10)
@end lisp

@subheading See Also
@ref{callback} @*
@ref{get-callback}




@c ===================================================================
@c CALLBACK

@node get-callback
@heading get-callback
@subheading Syntax
@Accessor{get-callback symbol => pointer}

(setf (@strong{get-callback} @emph{symbol) new-value})

@subheading Arguments and Values
@table @emph
@item symbol
A symbol denoting a callback.

@item new-value, pointer
A pointer.
@end table

@subheading Description
This is the functional version of the @code{callback} macro. It
returns a pointer to the callback named by @emph{symbol} suitable, for
example, to pass as arguments to foreign functions.

@subheading Examples
@lisp
CFFI> (defcallback sum :int ((a :int) (b :int))
        (+ a b))
SUM
CFFI> (get-callback 'sum)
#<A Mac Pointer #x102350>
CFFI> (setf (get-callback 'sum) (null-pointer))
#<A Null Mac Pointer>
CFFI> (get-callback 'sum)
#<A Null Mac Pointer>
@end lisp

@subheading See Also
@ref{callback} @*
@ref{defcallback}




@c ===================================================================
@c CHAPTER: Limitations

@node Limitations
@chapter Limitations


@node Symbol Index
@unnumbered Symbol Index
@printindex fn

@bye
